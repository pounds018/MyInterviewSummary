## 1. 概述:  
1. 几种insert语法:
```sql
   INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
       [INTO] tbl_name
       [PARTITION (partition_name [, partition_name] ...)]
       [(col_name [, col_name] ...)]
       { {VALUES | VALUE} (value_list) [, (value_list)] ...
         |
         VALUES row_constructor_list
       }
       [AS row_alias[(col_alias [, col_alias] ...)]]
       [ON DUPLICATE KEY UPDATE assignment_list]
   
   INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
       [INTO] tbl_name
       [PARTITION (partition_name [, partition_name] ...)]
       [AS row_alias[(col_alias [, col_alias] ...)]]
       SET assignment_list
       [ON DUPLICATE KEY UPDATE assignment_list]
   
   INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
       [INTO] tbl_name
       [PARTITION (partition_name [, partition_name] ...)]
       [(col_name [, col_name] ...)]
       [AS row_alias[(col_alias [, col_alias] ...)]]
       {SELECT ... | TABLE table_name}
       [ON DUPLICATE KEY UPDATE assignment_list]
   /**
   ps:
      value:
          {expr | DEFAULT}
      
      value_list:
          value [, value] ...
      
      row_constructor_list:
          ROW(value_list)[, ROW(value_list)][, ...]
      
      assignment:
          col_name = [row_alias.]value
      
      assignment_list:
          assignment [, assignment] ...
    */
```  
2. insert语句概述:  
   insert语句可以向现有的数据表中插入一行或者多行新数据.insert...values,insert ... values ROW(),和insert ... set 这三种语句会将指定数值插入到表中.  
   insert ... select 语句将其他表中查询出来的数据插入到表中.在MySQL 8.0.19版本以及之后的版本中,也可以使用insert ... table 将单表数据插入  
   insert ... on duplicate key update 语句,可以实现 当插入数据违反了 唯一约束或者主键约束的时候,对已经存在的数据进行更新而不是插入操作.8.0.19版本以及之后的版本,可以在on duplicate
   语句中可以使用 一个或者多个可选列的别名来关联待插入行的指定列数据
   > insert ... select 语句,更多信息详见 [insert ... select 语句](#2-insert--select-)  
   > insert ... on duplicate key update,更多信息详见 [insert ... on duplicate key update](#3-insert--on-duplicate-key-update-)  
   > insert ... delayed 语句在8.0版本,可以使用但是会被MySQL服务器忽略,具体原因见 [insert ... delayed 语句](#4-insert--delayed-)

   `insert语句`要想向 表中插入数据需要拥有该表的 `insert 权限`. 如果使用了 `insert ... on duplicate key update语句` 并且执行了 `update操作` 就需要拥有该表的
   `update权限`. 对于已读但未修改的列，就只需要`select权限`(例如，对于仅在on DUPLICATE KEY UPDATE子句中col_name=expr赋值语句右侧引用的列)。  
   当插入到分区表时,你可以选择插入到哪些分区和子分区中.PARTITION子句接受由逗号分隔的表中一个或多个分区或子分区(或两者)名称列表。如果给定的insert语句要插入的任何行与列出的分区之一不匹配，
   则INSERT语句将失败，错误为Found a row not matching the给定的分区集。有关更多信息和示例，请参见“分区选择”。
- `tal_name` 为数据将要插入的表名.按照下面几种方式为语句提供的数据指定列名:
   1. 在`tbl_name`之后,使用圆括号将由逗号分隔的列名括起来.这种方式,列名对应的数据值必须使用 value value_list,values(value_list),values[(value_list),(...)],
      select assignment_list语句.对于 `insert table语句`每行待插入数据列的数量要与表中列的数量相同
   2. 如果在 `tbl_name` 之后没有指定待插入的列名, 那么 values list,select语句,table语句就必须要为 `待插入表中所有列`提供数据.`即每行插入数据的字段个数要与表中字段个数相同`
   3. set 语句通过 `col_name=值` 的方式显示的给指定列分配具体值

- `column value`可以通过下列方式给出:
   1. 严格sql模式没有开启,任何没有指定的列都将(显示或者隐式)设置为默认值. 例如, 插入语句中提供了一个column列表,但是部分列是表中没有命名的,未命名的列就会被设置为默认值.
      `默认值的分配,详见DATA TYEP DEFAULT VALUES` 和 `关于无效数据的强制限制`  
      如果严格sql模式开启了,如果没有给无默认值的列在 `insert语句中` 指定具体的值,就会报错. `详见 server sql modes`
   2. 如果在insert语句中,既没有column_value_list 也没有 column_list的话, `insert 语句`就会插入一条全是默认值的数据.sql举例:
   ```sql
   insert into tbl_name () values();
   ```
  严格sql模式没有开启,对于任何一个没有显示设置默认值的列,在插入的时候MySQL都会使用隐式默认值.  
  严格SQL模式开启,如果存在任何一个没有默认值的列,都会发生错误.
   3. 使用default 关键字显示地给某一列设置默认值,可以让只给部分列插入值得时候编写sql更便捷.设置了之后可以不用给所有的字段都提供对应的值.
   4. 当显示生成列的时候,只能允许默认值. `详见CREATE TABLE and Generated Columns.`
   5. 语句中,可以使用 DEFAULT(col_name) 给col_name 生成默认值
   6. `insert语句`中提供的数据类型与字段要求的数据类型不同,就可能发生类型转换.由于字段类型的不同,插入数据的转换结果也不同.比如:

  > 1. string '1999.0e-2' 插入到 INT,FLOAT,DECIMAL(10,6) 或者 YEAR类型,插入结果为[1999,19.9921,19.992100,1999]  
       > INT,YEAR类型字段数据会转换成 1999,是因为 string -> int,year只会转换整数部分
       > float,decimal会按照不同精度要求转换数据的值,即将这个字符串视为有效数字的值

   7. 在待插入value_list中可以通过col_name获取到其在value_list中对应的值,注意: `只能获取到在value_list中当前字段之前字段的值`,比如:
   ```sql 
       INSERT INTO tbl_name (col1,col2) values(15, col1*2)
   ```

  > 下面这条语句就是错误的,因为col1引用了col2,但是col2还没有分配值

   ```sql
       INSERT INTO tbl_name (col1,col2) vlaues(col2*2,col1)
   ```

  > 注意: 任何设置了自增的字段,在使用上面这个语法的时候会出现异常情况,因为自增的值产生在其他值分配了之后,任何自增字段的引用在返回的时候总是`返回0`

3. `insert语句`可以使用values()语法来插入多条数据. `只需要使用逗号分隔单条数据插入的value_list`,比如:
   ```sql
   INSERT INTO tbl_anme (a,b,c) VALUES(1,2,3),(4,5,6),(7,8,9)
   ```
   每个value_list都需要包含与tbl_name后面的 col_name_list数量相同的value.下面这个就是错误的
   ```sql
   INSERT INTO tbl_name(a,b,c) values(12,3,1,2,3,2,31,1,3)
   ```
   上面这种写法,value()和values()的效果实际上是一样的.此时,value和values既不表示value_list中有多少个值,也不表示有多少个value_list. `即在插入一条语句的时候,
   使用value或者values都可以`
4. `insert语句`使用`values row()语句`同样可以插入多条数据.`就是将 原本写在values后面用()括起来的value_list,写到row()的括号里面去`,举个栗子:
   ```sql
   insert into tbl_name(a,b,c) values row(1,2,3),row(11,22,33),row(111,222,333);
   ```
   受到`insert语句`影响的行数,可以通过sql函数 `row_count()` 或者 c 语言api `mysql_affected_rows`.详见 [12.16, “Information Functions”, and
   mysql_affected_rows()](#2-insert--select-)
5. 返回结果信息解释:
   当使用 ` INSERT ... VALUES`, `INSERT ... VALUES ROW()`, `INSERT ... SELECT` 或者 `insert... table`等语句时,返回信息的格式为:
   ```sql
   Records: N1 Duplicates: N2 Warnings: N3
   ```
   使用c语言 api的话,可以通过调用 `mysql_info()`函数获取返回值信息.详见[mysql_info()](#2-insert--select-)  
   `Records字段`: 表示被该语句处理的记录条数[几行].(ps: records字段表示的不一定是实际插入的行数,因为duplicates字段可以是非零的)  
   `Duplicates字段`: 表示由于一些唯一约束的存在而不能被插入的记录条数[唯一条件重复的行数].  
   `Warnings字段`: 表示将要插入的数值在某些方法面是有问题的数量.以下几种情况会产生warning:
   - 向非空字段插入null.在批量插入语句(`insert ... values()等`)中,null将会根据字段类型转换成默认值(eg: 数值类型转换成0,字符串类型转换成'',时间类型转换成"zero").`insert...
     select语句`,服务器不会去检查select查询结果是单条数据还是多行数据,所以无论select返回的是单行数据还是多行数据,都会被当成是批量插入处理.
     >注意: 对于单行数据的 `insert语句`,是直接报错,而不是返回warning信息.
   - 向数值类型字段插入超出范围的值.`待插入值将会被截取成离他最近的一个取值范围的端点.`
   - 插入'10.34a'这中数据到数值类型字段. `截取第一个非数字字符之前的数字并插入,如果其实字符为非数值字符插入0`
   - 向字符串类型(char,varchar,text或者blob)字段插入超出要求长度的字符串. `超出最大长度以外的字符将会被丢弃,插入最大长度以内的字符串`
   - 插入非时间类型(date,time等)的数据到时间类型字段中. `该字段会被设置为时间类型的0值`
   - 向自增字段插入值的时候也可以产生warning,详见[Section 3.6.9, “Using AUTO_INCREMENT”.](#2-insert--select-).自增字段的值,可以通过sql
     (`LAST_INSERT_ID()`)或者c函数(`mysql_insert_id()`)获取
     > 注意: 这两个接口返回值不一定是一样的.详见[Section 12.16, “Information Functions”, and mysql_insert_id().](#2-insert--select-)

6. `insert语句`可以使用以下几种修饰符:
   - `LOW_PRIORITY`: insert语句将在没有任何一个client在读这张表的数据之后执行.只要有其他开始读取数据和已经存在的正在读取的client,`insert low_priority语句`就会等待读取操作的执行.
     因此,可能会由于一个client的长时间读操作造成插入语句长时间等待.  
     `LOW_PRIORITY`只会影响仅使用表锁的存储引擎,比如MyISAM,MEMORY,MERGE.
     > 建议: MyISAM存储引擎不要使用`LOW_PRIORITY`,因为它会造成并发插入不可用.详见[Section 8.11.3, “Concurrent Inserts”](#2-insert--select-)
   - `HIGH_PRIORITY`: 如果服务器启动时设置了 `--low-priority-updates`选项的话,`--low-priority-updates`的效果会被`HIGH_PRIORITY`覆盖.
     `HIGH_PRIORITY`一样会造成并发插入不可用.  
     `HIGH_PRIORITY`只会影响仅使用表锁的存储引擎,比如MyISAM,MEMORY,MERGE.
   - `IGNORE`: 忽略在执行`insert语句`的过程中发生的可忽略错误.比如发生`duplicate-key error`的时候,如果没有`IGNORE`修饰符的话,这条sql会被禁止执行;如果有`IGNORE`修饰,
     这条sql会被丢掉,而不是禁止执行,同时产生的是`warning`不是`error`.

     `IGNORE`修饰符在分区表插入的时候,作用与此相似,给定值没有匹配的分区的时候,`IGNORE`的作用就是将这些不匹配的值静默失败,并插入匹配的值.eg: [see Section 24.2.2, “LIST
     Partitioning”.](#2-insert--select-)

     不使用 `IGNORE`修饰符在类型转换错误的时候,会产生error导致sql被禁止执行.使用 `IGNORE`修饰符,错误类型的值会被替换成最为接近的值,并且产生warning同时不会禁止sql的执行.
     可以使用c函数mysql_info()来获取实际插入数据的条数.

     关于`IGNORE`更多的信息,详见[The Effect of IGNORE on Statement Execution.](#2-insert--select-)

     可以使用 `replace语句`替换 `insert语句` 来覆盖已经存在有冲突的旧值.`replace`的作用是 `删除旧记录,插入新纪录`. replace详见[Section 13.2.9, “REPLACE
     Statement”.](#2-insert--select-)
   - `ON DUPLICATE KEY UPDATE`: 在发生唯一约束冲突的时候,冲突的数据会被待插入数据修改,`注意既不是删除就记录插入新纪录,也不是直接报错`.  
     返回值为1,表示插入了一行新记录;返回值2,表示修改了一行数据;返回值0,表示将已有行设置成了当前值.  
     如果您在连接到mysqld时为mysql_real_connect() C API函数指定CLIENT_FOUND_ROWS标志，如果将现有行设置为其当前值，则受影响的行值为1(不是0)。 `on duplicate key
     update`详见[ Section 13.2.6.2, “INSERT ... ON DUPLICATE KEY UPDATE Statement”.](#3-insert--on-duplicate-key-update-)
   - `INSERT DELAYED`: 5.6版本被抛弃,计划删除,在8.0版本中,虽然可以写`DELAYED`修饰符,但是会被服务器忽略掉,实际上效果就是`INSERT`.详见[ Section 13.2.6.3, “INSERT
     DELAYED Statement.](#4-insert--delayed-)

## 2. insert ... select 语句:
## 3. insert ... on duplicate key update 语句:
## 4. insert ... delayed 语句:
