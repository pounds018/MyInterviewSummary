## 1. 单表delete:
```sql
    DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name
    [PARTITION (partition_name [, partition_name] ...)]
    [WHERE where_condition]
    [ORDER BY ...]
    [LIMIT row_count]
```  
> delete语句： 讲记录从表删除，并且返回已删除的行数。使用`ROW_COUNT`函数可以获取，`delete语句`的返回值
    
1. 主要的子句解释：  
    `where子句`: 通过 `where子句`中的条件来确定哪条语句被删除.`如果delete语句没有where子句,会删除整张表中的数据`.  
    `where_condition`这部分是个表达式,当表达式成立的时候,就表示该条记录符合删除条件,将其删除.[`where_condition详解`见13.2.9, “SELECT Statement”.](#1-)  
    `order by子句`: 如果sql语句中写了order by子句,满足删除条件的记录会按照order by中指定的顺序将数据删除.  
    `limit子句`: 通过`limit子句`可以限制表中被删除记录的数量.

## 2. 多表delete:
```sql
    DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    tbl_name[.*] [, tbl_name[.*]] ...
    FROM table_references
    [WHERE where_condition]

    DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    FROM tbl_name[.*] [, tbl_name[.*]] ...
    USING table_references
    [WHERE where_condition]
```
1. 权限:  
   `删除权限`: 删除表中记录的权限  
   `查询权限`: 在`where子句`中用于查询 
2. 性能:  
   - 当你不需要 `delete子句`的返回值的时候,用`TRUNCATE TABLE语句` 来 `清空` 表要比 无条件 `delete语句`的效率更好.  
   > `TRUNCATE TABLE语句`不能在事务,或者表(记录)被加上锁的时候使用. 详见 13.1.34 和 13.3.5  
   - 影响`delete语句`速度的因素:
   > 1. 删除单独记录的时间与索引的数量成正比(`删除记录的时候同样需要去维护索引`).如果要提高删除的效率,可以通过 提高 系统变量`key_buffer_size`
   > 来增加key的缓存数量,从而提高删除效率.
   > 2. 清空表的时候, `TRUNCATE TABLE`比 `delete from tbl_name`更高效.`Truncate`操作不支持事物特性;在事务中,或者加锁的数据上使用`Truncate table`
   > 就会报错.[详见 13.1.34]
   - 为了保证 `delete语句`不会耗时太长,可以使用`limit row_count`来限制删除记录的最大条数,即当需要被删除的数量大于`row_count`的时候,当删除到
   `row_count`之后,`row_count+1`条开始就从头开始再执行`delete语句`,直到被删除的数量比`row_count`小.  
3. 对分区表的支持:
   - `delete语句`支持 通过`parttion子句`显示地分区选择操作, `partition子句`包含一个由逗号分隔的一个或者多个分区(或子分区)的列表,然后从这个分区列表中选择要删除的数据.
    分区列表中没有的分区,会被忽略. `delete from t partition (p0)` 与 `alter table t truncate pattion (p0)`, 这两个语句的效果都是将分区(p0)中的数据清空  
   - `partition子句`也可以加上 `where语句`, 然后 `where语句`只对分区列表中的分区有用.比如 `delete from t patition (p0) where c < 5`.该语句表示`删除表t分区p0
    中 c列值小于5`的数据.表t其他分区中的数据不会去判断,也不会被删除.
   - `partition子句`也可以在 多表删除的语句中使用.`from中的表每个表,最多只能使用一个patition语句`
   - `partiton语句`详情见[ 22.5, “Partition Selection”.]
4. `auto-increment`列:
   - 如果删除的是 `auto-increment`列中值最大的数据,对于 `MyISAM表`或者`InnoDB`表中这个值是不会被再使用的.如果在`autocommit`模式,用
    `delete from tbl_name`语句删除这个表的所有数据的话,除了 `MyISAM`或者`InnoDB`以外的其他引擎都会重新排自增列的值.但是 对于 `InnoDB`中有例外情况:
    > 见[ 14.6.1.6, “AUTO_INCREMENT Handling in InnoDB”.] 
   - 对于 `MyISAM`引擎,可以在多列键中指定自增列的辅助列.在这种情况下，即使对于MyISAM表，也会重用从序列顶部删除的值。参见3.6.9节，“使用AUTO_INCREMENT”。
5. 修饰符:  
`delete语句`支持下面这几个修饰符:  
   - `LOW_PRIORITY`修饰符: 如果使用了`LOW_PRIORITY`修饰符,MySQL服务器会将 `delete`操作延迟到,没有其他客户端读取这张表的时候再执行.但是这种效果只会出现在
   只会出现在 `表级锁`的存储引擎上面,比如: MyISAM,MEMORY,MERGE.
   - `QUICK`修饰符: 对于`MyISAM`引擎的表,如果使用了`QUICK`修饰符,在删除的过程中,`MyISAM`引擎不会合并索引叶,这也可能增加一些删除操作的速度.  
   - `IGNORE`修饰符: `IGNORE`修饰符可以忽略删除过程中一些可忽略的错误.(解析阶段遇到的错误会以通常的方式处理).虽然可忽略的错误不再是错误,但是会返回一些警告.[ The Effect of IGNORE on Statement Execution.]
6. 删除的顺序:
   
## 3. insert ... on duplicate key update 语句:

## 4. insert ... delayed 语句: